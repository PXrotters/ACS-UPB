Lemnaru Mihai-Daniel - 322CD

	In contextul acestei teme, am dezvoltat un client HTTP, capabil sa comunice cu un server(ce va expune un API de tip REST). M-am bazat pe structura de baza a laboratorului 9 si am extins functionalitatea in fisierul client.c pentru a include parser-ul comenzilor introduse de la tastatura, precum si implementarea efectiva a comenzilor: register(efectueaza inregistrarea), login(efectueaza autentificarea), enter_library(cere acces in biblioteca), get_books(cere toate carţile de pe server), get_book(cere informaţie despre o carte), add_book(adauga o carte), delete_book(sterge o carte), logout(efectueaza delogarea utilizatorului), exit(efectueaza iesirea din program).

	HTTP 				-> Protocol stateless
					-> Foloseste paradigma request/response
	METODE HTTP			-> GET (Cereri de citire a unei pagini Web)
					-> POST (Adaugarea la resursa sepcificata)
					-> DELETE (Stergerea unei pagini Web)
	CODURI DE STARE 	-> Am folosti doar coduri pentru eroari gasite la client: 400(cerere incorecta), 401(neautorizat), 403(interzis), 404(pagina nu a fost gasita)


#requests.c:
*compute_get_request 	-> Functia este responsabila pentru construirea unui mesaj de tip GET pentru a fi trimis catre un server HTTP. Acest mesaj contine informatii precum metoda HTTP (GET), URL-ul, parametrii de interogare (daca exista), adresa gazda si alte antete optionale cum ar fi tokenul de autorizare si cookie-urile.
			-> Initializeaza un mesaj si un sir pentru linie.
			-> Construieste linia de solicitare care contine metoda HTTP (GET), URL-ul si, optional, parametrii de interogare.
			-> Adauga antetele necesare, cum ar fi gazda si, daca este disponibil, tokenul de autorizare si cookie-urile.
			-> Returneaza mesajul construit.

*compute_post_requset	-> Functia este responsabila pentru construirea unui mesaj de tip POST pentru a fi trimis catre un server HTTP. Acest mesaj contine informatii precum metoda HTTP (POST), URL-ul, tipul de continut, lungimea continutului, adresa gazda si alte antete optionale cum ar fi tokenul de autorizare si cookie-urile.
			-> Initializeaza un mesaj si un sir pentru linie.
			-> Construieste linia de solicitare care contine metoda HTTP (POST) si URL-ul.
			-> Adauga antetele necesare, cum ar fi gazda, tipul de continut si lungimea continutului.
			-> Adauga, daca este disponibil, tokenul de autorizare si cookie-urile.
			-> Adauga corpul cererii POST la mesaj.
			-> Returneaza mesajul construit.

*compute_delete_request -> Functia este responsabila pentru construirea unui mesaj de tip DELETE pentru a fi trimis catre un server HTTP. Acest mesaj contine informatii precum metoda HTTP (DELETE), URL-ul, adresa gazda si alte antete optionale, cum ar fi tokenul de autorizare si cookie-urile.
			-> Initializeaza un mesaj si un sir pentru linie.
			-> Construieste linia de solicitare care contine metoda HTTP (DELETE) si URL-ul.
			-> Adauga gazda ca antet.
			-> Adauga, daca este disponibil, tokenul de autorizare si cookie-urile.
			-> Adauga un rand gol pentru a indica finalul cererii.
			-> Returneaza mesajul construit.   


#client.c:
*is_numeric_string 	    -> Aceasta functie recursiva primeste un sir de caractere str si un index index. Verifica daca caracterul de la pozitia index este unul dintre caracterele care reprezinta un numar. Daca da, se apeleaza recursiv pentru urmatorul caracter. Daca caracterul este '\0', functia returneaza 1, indicand ca intregul sir este numeric. Altfel, daca caracterul nu este unul dintre caracterele numerice, functia returneaza 0.

*is_numeric     	    -> Aceasta functie apeleaza "is_numeric_string" pentru a verifica daca intregul sir este numeric incepand de la prima pozitie.

*register_user  	    -> Aceasta functie este responsabila pentru inregistrarea unui utilizator in sistem dupa cum urmeaza:
	        -> Input de la utilizator: Se aloca memorie pentru a citi username-ul si parola introduse de utilizator de la tastatura (input_username si input_password). Se solicita utilizatorului sa introduca aceste informatii si se elimina eventualele caractere newline (\n) de la sfarsitul lor.
			-> Verificare spatii: Se verifica daca username-ul si parola contin spatii (caractere de spatiu, tab, newline, etc.). Daca da, se afiseaza o eroare si functia se incheie.
			-> Crearea obiectului JSON: Se construieste un obiect JSON care contine username-ul si parola introduse de utilizator.
			-> Generarea cererii HTTP: Se construieste mesajul de cerere HTTP POST care contine obiectul JSON si alte informatii necesare.
			-> Trimiterea cererii la server: Se deschide o conexiune catre server, se trimite cererea si se asteapta un raspuns.
			-> Interpretarea raspunsului: Se interpreteaza raspunsul primit de la server, verificandu-se codul de raspuns HTTP.
			-> Afisarea rezultatului: Daca inregistrarea a fost realizata cu succes, se afiseaza un mesaj corespunzator. in caz contrar, se afiseaza o eroare, indicand ca username-ul este deja folosit.
			-> Eliberarea memoriei: Se elibereaza memoria alocata pentru username, parola si alte variabile temporare.

*login_user		        -> Aceasta functie este responsabila pentru autentificarea unui utilizator in sistem, asemanator cu pasii descrisi in functia "register_user".

*check_library_access 	-> Aceasta functie are rolul de a verifica accesul unui utilizator la biblioteca dupa cum urmeaza:
			-> Verificare token de autorizare: Se verifica daca utilizatorul are deja un token de autorizare (inseamna ca deja are acces la biblioteca). Daca da, se afiseaza un mesaj de eroare si functia se incheie.
			-> Generare cerere HTTP GET: Se construieste o cerere HTTP GET pentru a verifica accesul la biblioteca. Aceasta cerere poate include si cookie-urile primite anterior de la server, daca exista.
			-> Receptionare raspuns de la server: Se primeste raspunsul de la server.
			-> Interpretare cod de raspuns HTTP: Se interpreteaza codul de raspuns HTTP primit de la server si se verifica daca utilizatorul este autentificat. Daca nu este autentificat, se afiseaza un mesaj de eroare si functia se incheie.
			-> Extrage token-ul de autorizare: Daca utilizatorul este autentificat, se extrage token-ul de autorizare din raspunsul primit de la server si se stocheaza in variabila authorization_token. Aceasta indica faptul ca utilizatorul are acum acces la biblioteca.
			-> Afisarea rezultatului: Se afiseaza un mesaj corespunzator, indicand ca accesul la biblioteca a fost autorizat.
			-> Eliberarea memoriei si inchiderea conexiunii: Se elibereaza memoria alocata pentru variabilele temporare si se inchide conexiunea la server.

*display_books		    -> Aceasta functie primeste un sir de caractere server_response care contine informatiile despre carti sub forma unui obiect JSON. Functia cauta inceputul listei de carti in raspunsul serverului, apoi il parseaza si afiseaza detaliile cartilor. Daca lista este goala, afiseaza un mesaj corespunzator.

*get_books		        -> Aceasta functie este responsabila pentru obtinerea listei de carti de la server si apelul functiei display_books pentru afisarea acestora.
			-> Generarea cererii HTTP GET: Se construieste o cerere HTTP GET pentru a obtine lista de carti de la server, utilizand token-ul de autorizare, daca este disponibil.
			-> Trimiterea cererii la server: Se deschide o conexiune catre server si se trimite cererea HTTP GET.
			-> Receptionarea raspunsului de la server: Se primeste raspunsul de la server, care contine lista de carti sau un cod de eroare, in cazul in care accesul la biblioteca este refuzat.
			-> Interpretarea raspunsului: Se interpreteaza raspunsul primit de la server pentru a verifica daca accesul la biblioteca este permis sau nu. Daca este permis, se apeleaza functia display_books pentru a afisa lista de carti.
			-> Eliberarea memoriei si gestionarea erorilor: Se elibereaza memoria alocata si se gestioneaza erorile de alocare a memoriei sau de comunicare cu serverul.

*display_book_details 	-> Asemanator cu functia display_books

*get_book		-> Aceasta functie este responsabila pentru obtinerea detaliilor unei carti de la server, in functie de id-ul cartii furnizat de utilizator.
			-> Cere id-ul cartii de la utilizator: Se solicita utilizatorului sa introduca id-ul cartii.
			-> Verifica id-ul cartii: Se verifica daca id-ul introdus de utilizator este un numar valid. Daca nu este, se afiseaza un mesaj de eroare si functia se incheie.
			-> Construieste URL-ul cererii HTTP GET: Se construieste URL-ul pentru cererea HTTP GET, care contine id-ul cartii, folosind functia sprintf.
			-> Trimite cererea la server si primeste raspunsul: Se trimite cererea HTTP GET la server si se primeste raspunsul.
			-> Interpreteaza raspunsul de la server: Se interpreteaza raspunsul primit de la server pentru a verifica daca accesul este permis si daca cartile au fost gasite sau nu.
			-> Afiseaza detaliile cartii: Daca cartile au fost gasite si accesul este permis, se afiseaza detaliile cartii folosind functia display_book_details.
			-> Elibereaza memoria si gestioneaza erorile: Se elibereaza memoria alocata si se gestioneaza erorile de alocare a memoriei sau de comunicare cu serverul.

*delete_book		    -> Aceasta functie este responsabila pentru stergerea unei carti din biblioteca pe baza id-ului cartii furnizat de utilizator.
			-> Alocarea memoriei pentru id-ul cartii: Se aloca memorie pentru a stoca id-ul cartii.
			-> Cere id-ul cartii de la utilizator: Utilizatorul este solicitat sa introduca id-ul cartii pe care doreste sa o stearga.
			-> Verificare id-ul cartii: Se verifica daca id-ul introdus de utilizator este un numar valid. Daca nu este, se afiseaza un mesaj de eroare si functia se incheie.
			-> Construirea URL-ului pentru cererea de stergere: Se construieste URL-ul cererii de stergere a cartii, care contine id-ul cartii.
			-> Trimiterea cererii la server si primirea raspunsului: Se trimite cererea HTTP DELETE la server pentru a sterge cartile si se primeste raspunsul de la server.
			-> Interpretarea raspunsului de la server: Se interpreteaza raspunsul primit de la server pentru a verifica daca accesul este permis si daca cartile au fost gasite sau nu.
			-> Afisarea mesajului de confirmare: Daca cartile au fost sterse cu succes, se afiseaza un mesaj de confirmare.
			-> Eliberarea memoriei si gestionarea erorilor: Se elibereaza memoria alocata si se gestioneaza erorile de alocare a memoriei sau de comunicare cu serverul.

*read_input		        -> Aceasta functie primeste un prompt si citeste inputul utilizatorului de la tastatura, pana la intalnirea unui newline sau pana cand s-a citit un numar maxim de caractere specificat (max_len). Inputul citit este alocat dinamic in memorie si returnat ca un sir de caractere.

*add_new_book		    -> Aceasta functie permite utilizatorului sa introduca detaliile unei carti noi si sa le adauge in biblioteca.
			-> Citirea detaliilor cartii: Se foloseste functia "read_input" pentru a citi titlul, autorul, editorul, genul si numarul de pagini ale cartii.
			-> Verificarea validitatii detaliilor cartii: Se verifica daca toate campurile cartii au fost completate si daca numarul de pagini este un numar valid.
			-> Crearea obiectului JSON pentru payload: Se creeaza un obiect JSON si se seteaza valorile pentru detaliile cartii.
			-> Serializarea obiectului JSON: Obiectul JSON este serializat intr-un sir de caractere JSON folosind functia json_serialize_to_string_pretty.
			-> Trimiterea cererii de adaugare a cartii la server: Se trimite o cerere HTTP POST la server pentru a adauga cartile in biblioteca, impreuna cu payload-ul JSON care contine detaliile cartii.
			-> Interpretarea raspunsului de la server: Se interpreteaza raspunsul primit de la server pentru a verifica daca adaugarea cartii a fost reusita sau nu.
			-> Eliberarea memoriei si gestionarea erorilor: Se elibereaza memoria alocata si se gestioneaza erorile de alocare a memoriei sau de comunicare cu serverul.

*logout			        -> Aceasta functie logout este responsabila pentru deconectarea utilizatorului din sistem.
			-> Generarea cererii de deconectare: Se foloseste functia compute_get_request pentru a genera o cerere de tip GET catre ruta /api/v1/tema/auth/logout. Aceasta cerere este trimisa fara a transmite un token de autorizare, dar cu cookie-urile primite in timpul sesiunii.
			-> Deschiderea conexiunii si trimiterea cererii: Se deschide o conexiune catre server folosind open_connection si se trimite cererea de deconectare utilizand send_to_server.
			-> Receptionarea raspunsului de la server: Se primeste raspunsul de la server folosind receive_from_server.
			-> Interpretarea codului de raspuns: Se interpreteaza codul de raspuns pentru a determina daca deconectarea a fost sau nu efectuata cu succes. Daca raspunsul indica o cerere incorecta, se afiseaza un mesaj de eroare. in caz contrar, se efectueaza operatiile necesare pentru deconectare.
			-> Eliberarea resurselor si actualizarea starii de autentificare: Daca deconectarea este efectuata cu succes, token-ul de autorizare este eliberat si variabilele asociate cu cookie-urile primite sunt resetate.

*main 			        -> Gestioneaza interactiunea utilizatorului cu serverul prin intermediul comenzilor de la linia de comanda.
			-> Initializare variabile: Se initializeaza variabilele pentru cookies, tokenul de autorizare si numarul de cookies.
			-> Citirea comenzilor utilizatorului: Se utilizeaza o bucla while pentru a citi comenzile introduse de utilizator de la linia de comanda pana cand este introdusa comanda "exit".
			-> Executarea comenzilor: Se verifica fiecare comanda introdusa de utilizator si se executa functia corespunzatoare. Daca comanda este necunoscuta sau nu este executata cu succes, se afiseaza un mesaj corespunzator.
			-> Eliberarea resurselor si inchiderea conexiunilor: Dupa fiecare comanda executata, se elibereaza memoria alocata pentru mesaje si se inchid conexiunile active, daca exista.
			-> incheierea programului: Dupa ce utilizatorul introduce comanda "exit", bucla se incheie si memoria alocata pentru variabilele utilizate este eliberata inainte de incheierea programului.