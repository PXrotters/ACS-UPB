Lemnaru Mihai-Daniel - 322CD

Comunicarea de la client la server:
-Transmiterea ID-ului clientului la conectare: Clientul trimite ID-ul sau la conectare pentru a identifica si autentifica conexiunea catre server.
-Emisia comenzii de abonare (subscribe) la un anumit topic: Clientul emite o comanda de abonare pentru a se abona la actualizarile unui anumit topic de interes.
-Emisia comenzii de dezabonare (unsubscribe) de la un topic: Clientul emite o comanda de dezabonare pentru a se dezabona de la actualizarile unui topic la care este deja abonat.

Comunicarea de la server la client:
-Transmiterea actualizarilor topic-urilor abonate: Serverul informeaza clientul despre orice actualizari sau evenimente legate de topic-urile la care clientul este abonat, permitandu-i sa primeasca si sa proceseze informatiile relevante.

#helpers.h:
*struct udp_message -> Structura definita prin care serverul primeste mesaje de la udp.
*struct subscriber_message -> Structura prin care serverul primeste mesaje de la clientul tcp. Contine comanda primita de subscribe/unsubscribe , topic-ul la care face referire, respectiv daca vrea sau nu sa activeze optiunea sf.
struct server_message -> Structura care ajuta serverul sa trimita mesaje catre serverul tcp. Contine lungimea mesajului trimis, adresa , topicul la care face referire mesajul si tipul de date pe care il trimite.
*struct subscriber -> Structura care salveaza datele subscriberilor. Contine id-ul fiecaruia, socketul , conectivitatea acestuia, 2 vectori care retin topic-ul la care e abonat subscriber-ul respectiv daca el are flag-ul setat si numarul de topicuri pe care le retine el in subscription.

#server.c:
*findSubscriberByClientId -> Functie care cauta un abonat intr-un tablou de structuri de abonat, pe baza ID-ului sau de client. Functia este implementata recursiv si cauta abonatul in intregul tablou.
*findTextByInfo -> Functie care cauta un text intr-un tablou bidimensional de caractere, pe baza unei informatii date. Functia este implementata recursiv si cauta textul in intregul tablou.
*findSubscribers -> Functie care cauta un abonat intr-un tablou de structuri de abonat, pe baza descriptorului de fisier al socket-ului sau. Functia este implementata recursiv si cauta abonatul in intregul tablou.
*prepareServerForComm -> Functie care pregateste serverul pentru a primi conexiuni TCP si UDP pe un anumit port. Ea configureaza optiunile socket-ului, leaga socket-urile la adresa specificata si le pregateste sa primeasca conexiuni.
*handleExitCommand -> Functie care gestioneaza comanda de iesire primita de la client. Ea inchide toate socket-urile asociate cu clientii conectati, elibereaza memoria alocata pentru tabloul de abonati si inchide socket-urile TCP si UDP ale serverului inainte de a incheia programul.
*handleUdpMessage -> Functie care primeste un mesaj UDP si il proceseaza pentru a-l trimite catre abonatii interesati. Ea verifica lista de abonati pentru a determina cine este interesat de mesaj si trimite mesajul catre acestia.
*handleUdp -> Functie care primeste mesaje UDP de la clienti si le gestioneaza utilizand functia `handleUdpMessage`. Ea primeste mesajele prin socket-ul UDP si le trimite mai departe pentru procesare.
*handleTcpConnection -> Functie care primeste o conexiune TCP noua si gestioneaza conectarea clientului asociat. Ea verifica daca clientul este nou sau deja conectat si efectueaza actiunile corespunzatoare in functie de situatie.
*handleSubscriberMessage -> Functie care primeste un mesaj de la un abonat si actualizeaza lista de abonamente a abonatului in functie de comanda primita (subscirbe/unsubscribe).
*main -> Se verifica daca a fost furnizat portul serverului ca argument in linia de comanda. in caz contrar, se afiseaza un mesaj de utilizare si se incheie executia. Se seteaza buffer-ul pentru iesirea standard (stdout) sa fie neliniarizat pentru a asigura afisarea imediata a mesajelor. Se creeaza doua socket-uri pentru comunicatie: unul pentru TCP si altul pentru UDP. Se initializeaza structurile de adresa pentru clienti si server si se configureaza portul serverului. Se utilizeaza functia prepareServerForComm pentru a configura optiunile socket-urilor si pentru a lega si asculta conexiuni pe acestea.
      -> Se foloseste functia poll pentru a astepta evenimente pe mai multe descriptori de fisiere, incluzand socket-urile TCP si UDP, precum si intrarea standard (STDIN). Serverul este blocat in asteptarea unui eveniment pana cand unul se intampla. Atunci cand se detecteaza un eveniment, se verifica descriptorul de fisier asociat si se executa actiunile corespunzatoare.
      -> Evenimente de la STDIN: Daca se detecteaza un eveniment de la intrarea standard, se citesc comenzile de la utilizator. Daca comanda este "exit", serverul se inchide, gestionand in mod corespunzator eliberarea resurselor si inchiderea conexiunilor existente. Evenimente de la UDP: Serverul primeste mesaje UDP de la abonati si le proceseaza folosind functia handleUdp. Evenimente de la TCP: Atunci cand se detecteaza o noua conexiune TCP, serverul o accepta si gestioneaza conexiunea folosind functia handleTcpConnection. De asemenea, serverul primeste si proceseaza mesaje de la abonati TCP existenti.
      -> Se utilizeaza functii specifice pentru a gestiona abonatii si mesajele lor. De exemplu, functia handleSubscriberMessage proceseaza mesajele primite de la abonati si actualizeaza informatiile despre abonamentele acestora. Dupa ce serverul primeste comanda "exit" sau se incheie executia, se elibereaza toate resursele si se inchid toate conexiunile deschise, inclusiv socket-urile TCP si UDP si se elibereaza memoria alocata pentru lista de abonati.

# subscriber.c
*show_int -> Functia primeste lungimea datelor si un pointer catre bufferul care contine aceste date. Din buffer, se extrage un intreg (de tip int) care este apoi afisat. Valoarea intreaga este convertita din reprezentarea retea (big-endian) in reprezentarea gazda (host) folosind functia ntohl. La final, se goldeste bufferul de iesire pentru a asigura afisarea imediata a mesajului.
*show_short_real -> Functia primeste lungimea datelor si un pointer catre bufferul care contine aceste date. Din buffer, se extrage un numar scurt (de tip short) care reprezinta valoarea reala. Valoarea reala este apoi convertita din reprezentarea retea (big-endian) in reprezentarea gazda (host) folosind functia ntohs. La final, se goldeste bufferul de iesire pentru a asigura afisarea imediata a mesajului.
*show_float -> Functia primeste lungimea datelor si un pointer catre bufferul care contine aceste date. Se extrage prima data exponentul (p) din bufferul de date. Aceasta reprezinta numarul de zecimale pe care il va avea valoarea reala. Apoi, se extrage valoarea reala (nrfloat) din bufferul de date. Ambele valori sunt convertite din reprezentarea retea (big-endian) in reprezentarea gazda (host) folosind functia ntohl. Valoarea reala este calculata utilizand formula (double)ntohl(nrfloat) / pow(10, p), care corecteaza valoarea reala in functie de exponent. La final, se goldeste bufferul de iesire pentru a asigura afisarea imediata a mesajului.
*show_string -> Functia primeste lungimea datelor si un pointer catre bufferul care contine aceste date. Se creeaza un buffer suplimentar text cu o lungime fixa de 1501 de caractere, pentru a stoca stringul. Se copiaza datele din bufferul de intrare buff in bufferul text. Se adauga terminatorul de sir \0 la sfarsitul sirului pentru a-l transforma intr-un sir de caractere valid.La final, se goldeste bufferul de iesire pentru a asigura afisarea imediata a mesajului.
*show_message -> Se defineste un vector de pointeri la functii numit show_message_functions, care este initializat cu adresele functiilor show_int, show_short_real, show_float si show_string. Functia show_message primeste tipul mesajului, lungimea datelor si un pointer catre bufferul care contine aceste date. Se verifica daca type este mai mic decat numarul de functii din vectorul show_message_functions. Daca da, se apeleaza functia corespunzatoare tipului de mesaj, folosind pointerul la functie din vector si pasand lungimea si bufferul de date ca argumente. in caz contrar, se afiseaza un mesaj ca tipul mesajului este necunoscut.
*check_error -> Functia check_error primeste o conditie si un mesaj de eroare. Verifica daca conditia este adevarata. Daca este adevarata, afiseaza mesajul de eroare utilizand functia perror si incheie executia programului utilizand exit(EXIT_FAILURE). in caz contrar, functia se incheie fara a face nimic.
*establishTcpConnWithServer -> Functia configureaza optiunea TCP_NODELAY pentru a dezactiva algoritmul de amanare a pachetelor (Algoritmul Nagle). Initializeaza si configureaza adresa serverului utilizand adresa IP si portul furnizate in argumentele liniei de comanda. Activeaza optiunea SO_REUSEADDR pentru a permite reutilizarea adresei locale a socket-ului. Realizeaza conexiunea la server utilizand functia connect. Trimite ID-ul clientului catre server, pentru identificare.
*handleSubscriptionsAndMessages -> Aceasta functie este responsabila pentru gestionarea abonamentelor si mesajelor intr-un client care comunica cu serverul utilizand socket-uri TCP. Functia utilizeaza poll() pentru a astepta evenimente de intrare pe doua surse: STDIN_FILENO (pentru intrarea de la utilizator) si socket-ul TCP (pentru mesajele de la server). Atunci cand primeste un eveniment de la STDIN_FILENO, functia citeste comanda introdusa de utilizator de la tastatura. Daca comanda este "exit", functia se opreste si iese din bucla. Daca comanda este "subscribe" sau "unsubscribe", functia pregateste un mesaj de abonament sau dezabonament si il trimite la server prin socket-ul TCP. Atunci cand primeste un eveniment pe socket-ul TCP: Functia primeste mai intai un mesaj de la server care contine informatii despre mesajul urmator. Apoi, functia primeste efectiv mesajul de la server. Functia afiseaza informatiile mesajului (adresa IP si portul clientului care a trimis mesajul, precum si continutul mesajului).
*main -> Functia isi incepe executarea prin eliminarea bufferului de iesire, pentru a asigura afisarea imediata a mesajelor pe ecran. Verifica daca numarul de argumente de la linia de comanda este corect. Daca nu, afiseaza un mesaj de utilizare si iese din program. Creeaza un socket TCP utilizand socket(AF_INET, SOCK_STREAM, 0). Daca nu se poate crea socket-ul, functia se incheie si afiseaza un mesaj de eroare. Initializeaza conexiunea TCP cu serverul folosind functia establishTcpConnWithServer(tcp, argv). Gestioneaza abonamentele si mesajele cu serverul utilizand functia handleSubscriptionsAndMessages(tcp). Dupa ce functia handleSubscriptionsAndMessages se incheie (adica cand utilizatorul introduce comanda "exit"), inchide socket-ul TCP si se termina cu codul de iesire 0.