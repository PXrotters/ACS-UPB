	Banda magica (lista dublu inlantuita cu santinela) impreuna cu degetul (pozitia curenta in banda), coada (unde vor fi adaugate comenzile intalnite in fisier) si stiva (atat pentru UNDO cat si pentru REDO) au fost implementate cu cate o structura. Pentru coada am creat o functie de dezalocare a memoriei. Pentru stiva am creat patru functii una de push (adaugare in stiva), una de pop (eliminare din stiva), una de golire a stivei si una de dezalocare. Pentru functia push vom crea un nou nod care va retine pozitia degetului urmand sa facem legatura cu varful stivei, nodul creat devenind noul varf. Functia pop va elimina varful stivei. Functia de golire va elimina, pe rand, incepand din varful stivei toate nodurile existente in stiva respectiva. Functia de free va dezaloca toata memoria stivei respective. De asemenea avem si o functie de free pentru lista/banda. Vom avea o functie pentru initializarea listei dublu inlantuite aceata alocand memorie pentru santinela si deget, santinela fiind primul nod din stiva, de care nu ne vom atinge, iar urmatorul nod (acesta fiind defapt primul nod considerat) este degetul (pozitia curenta in banda). Degetul va primi ca si valoare caracterul '#', urmand sa se faca toate legaturile necesare intre aceste noduri, in final functia returnand un element de tip lista (structura care contine santinela si degetul -> lista dublu inlantuita). Vom mai avea o functie pentru initializarea unui nou nod care va primi valoarea '#' si legaturile de next si prev catre NULL.
	Urmeaza sa cream functiile pentru anumite operatii. Avem functia pentru operatia de "MOVE_RIGHT" care creaza un nod nou verifica daca degetul se afla pe ultima pozitie si il adauga la finalul benzii sau in caz contrar va deplasa pozitia degetului pe pozitia urmatoare (finger -> next), returnand pozitia actuala a degetului. Functia pentru operatia de "MOVE_LEFT" care creaza verifica daca degetul se afla pe prima pozitie in banda (urmatorul nod dupa santinela) returnand pozitia actuala a degetului fara a face vreo modificare sau in caz contrar mutam degetul pe pozitia anterioara (finger -> prev). Functia pentru operatia "INSERT_LEFT" va crea un nod nou verifica daca pozitia degetului nu se afla pe prima pozitie si in caz afirmativ nodul va primi valoarea unui caracter (ultimul caracter din sirul "INSERT_LEFT X", unde X poate primi orice caracter citit de la tastatura), si vom face toate legaturile neceasare astfel incat acest nod sa fie inserat inainte pozitiei curente in banda, pozitia curenta mutandu-se pe nodul inserat. La final vom returna noua pozitie a degetului indiferent ca s-au efectuat comenzile descrise anterior sau nu. Functia pentru operatia INSERT_RIGHT asemanator va crea un nod nou, dar va verifica daca degetul se afla pe ultima pozitie in banda sau in interior pentru a putea stabili legaturile corespunzatoare. La final se va returna pozitia acutala a degetului. Functia pentru operatia "MOVE_LEFT_CHAR" va retine pozitia actuala a degetului si va parcurge de la pozitia actuala pana la santinela toate nodurile verificand daca valoarea din noduri este egala cu caracterul primit ca parametru al functiei (ultimul caracter din sirul "MOVE_LEFT_CHAR X", unde X poate primi orice caracter citit de la tastatura). In caz afirmativ returnam valoarea actuala a degetului si oprim deplasarea (cautarea), altfel daca am ajuns cu degetul pe pozitia santinelei, vom returna valoarea degetului retinuta la inceputul functiei. Functia pentru operatia "MOVE_RIGHT_CHAR" va crea un nod, va incepe o parcurgere de la pozitia degetului pana la finalul benzii, verificand daca valorile din nodurile benzii identice cu caracterul primit ca parametru al functiei (ultimul caracter din sirul "MOVE_RIGHT_CHAR X", unde X poate primi orice caracter citit de la tastatura). In caz afirmativ returnam valoare actuala a degetului si oprimt deplasarea, altfel daca am ajuns cu degetul la finalul benzii vom adauga nodul creat initial la finalul benzii si vom muta pozitia degetului pe acest nod (acesta nu va prelua valoarea caracterului ci va ramane cu valoarea '#').
	In functia principala vom deschide fisierele pentru citire, respectiv scriere, vom initializa anumite variabile ajutatoare, vom seta capul si finalul cozii, respectiv varful stivei pentru "UNDO" si "REDO" pe NULL. Verificam daca fisierele s-au deschis cu succes, urmand sa citim pe rand fiecare linie din fisier, pe care o vom salva intr- o variabila. Daca comanda respectiva este de tip UPDATE o vom aduga in coada (Vom aloca memorie pentru un nou nod care va retine ca si valoare comanda citita din fisier si vom verifica daca capul cozii (front) este NULL iar spatele/finalul cozii (rear) este, de asemenea, NULL ambele vor pointa catre nodul creat, altfel inseamna ca avem elemente in coada si vom pointa cu rear-ul catre nodul creat, acesta devenind noul rear). Daca comanda este de tip "EXECUTE" verificam daca cumva coada noastra a fost updatata si parcursa in intregime anterior, urmand sa fi fost introduse ulterior comenzi. In cazul afirmativ capul cozii va deveni urmatorul nod din coada. (Altfel daca nu am face acesata verifica si cumva coada a fost parcursa anterior in intregime si apoi au fost adaugate comenzi, capul va ramane pe pozitia ultimul element din vechea coada, deoarece head-ul nu va pointa catre NULL, iar cand vom apela functia de enqueue nodurile vor fi adaugate doar la finalul cozii, capul ramanand nemodificat). Vom avea nevoie de o variabila care va retine pozitia capului in coada, acesta urmand sa se deplaseze pe urmatoarea pozitie. Acum vom verifica ce comanda se afla in nodul din coada. Daca este "MOVE_RIGHT" vom adauga pozitia degetului in coada pentru "UNDO" si vom face deplasarea catre dreapta in banda. Daca este "MOVE_LEFT" retinem pozitia degetului, apelam functia pentru "MOVE_LEFT", verificam daca pozitia actuala a degetului s-a schimbat fata de cea anterioara si adaugam pozitia anterioara in stiva pentru "UNDO", altfel nu adaugam nimic. Daca este "WRITE X" (unde X poate fi orice caracter) valoarea nodului din lista unde se afla degetul va fi 'X', urmand sa golim stivele pentru "UNDO" SI "REDO", deoarece se garanteaza ca nu vom avea operatii de "UNDO"/"REDO" peste cele de WRITE. Daca este "MOVE_LEFT_CHAR X" (unde X poate fi orice caracter) retinem pozitia degetului curent, verifica daca valoarea nodului din lista unde se afla degetul coincide cu 'X', apelam functia pentru "MOVE_LEFT_CHAR", si analizam daca verificarea anterioara este falsa si pozitia degetului nu s-a modificat vom creste o variabila care ne va ajuta sa decidem in momentul cand facem afisarea daca afisam "ERROR" sau nu. Daca este "MOVE_RIGHT_CHAR X" (unde X poate fi orice caracter) apelam functia pentru "MOVE_RIGHT_CHAR" si golim stivele pentru "UNDO" si "REDO", deoarece se garanteaza ca nu vom avea operatii de "UNDO"/"REDO" peste cele de WRITE. Analog pentru intalnirea comenzii "INSERT_RIGHT". Pentru "INSERT_LEFT X" (unde X poate fi orice caracter) retinem pozitia degetului curent apelam functia pentru "INSERT_LEFT" verificam daca pozitia degetului s-a modificat, iar in caz negativ crestem variabila pentru ajutarea in afisarea mesajului "ERROR". De asemenea, golim stivele pentru "UNDO" si "REDO", deoarece se garanteaza ca nu vom avea operatii de "UNDO"/"REDO" peste cele de WRITE. La final, tot in execute vom verifica daca capul, coada si variabila care a retinut head-ul anterior sunt egale, vom retine adresele acestora intr-o alta variabila care ne va ajuta sa indeplinim prima verificare din execute. Daca comanda din sirul care retine liniile din fisier este "UNDO" adaugam in stiva pentru "REDO" pozitia degetului, dupa care o actualizam mutand-o pe pozitia stocata in varful stivei "UNDO" si eliminam nodul din varful stivei "UNDO". Analog pentru inalnirea comenzii "REDO". Daca comanda este "SHOW" verificam daca am actualizat variabila de error in operatiile de tip UPDATE, afisand mesajul "ERROR" in caz afirmativ, urmand sa parcurgem de la inceputul benzii pana la final si afisand toate valorile stocate in noduri. Pentru nodul care reprezinta pozitia actuala a degetului, valoarea va fi incadrata in modul :"| |". La final resetam variabila pentru error. Daca comanda citita este "SHOW_CURRENT" verificam daca am actualizat variabila de error in operatiile de tip UPDATE, afisand mesajul "ERROR" in caz afirmativ, urmand sa afisam numai valoarea nodului, unde se afla degetul. Toate verificarile de mai sus vor fi reluate pentru toate comenzile din fisier. Comenzile care nu au legatura cu operatiile explicate vor fi ignorate (prima linie din fisier care reprezinta numarul de comenzi din fisier). La final vom apela functiile de free pentru coada, pentru ambele stive si pentru lista dublu inalntuita.
